import os
import importlib
from importlib.resources import files
import asyncio
from typing import Callable, List, Tuple, Optional, Any, TYPE_CHECKING
from prompt_toolkit.lexers import Lexer, SimpleLexer
from prompt_toolkit.document import Document
from prompt_toolkit.application import get_app
from tree_sitter import Language, Parser, Query, Tree
from sno_py.di import container

if TYPE_CHECKING:
    from sno_py.filetypes.filetypes import FileType
    from sno_py.config import Config
    from sno_py.editor import Editor

StyleAndTextTuples = List[Tuple[str, str]]


class TreeSitterLexer(Lexer):
    """A lexer that utilizes Tree-sitter for syntax highlighting, supporting language injections.

    Attributes:
        parser (Parser): The tree-sitter parser for the main language.
        language (str): The language identifier for syntax highlighting.
        highlight_query (Optional[Query]): Tree-sitter query for syntax highlights.
        injection_query (Optional[Query]): Tree-sitter query for language injections.
        tree (Optional[Tree]): The parse tree generated by tree-sitter.
        last_text (str): The last processed text for caching.
        cached_styles (List[StyleAndTextTuples]): Styles cached from the last parsing operation.
        highlighting_task (Optional[asyncio.Task]): The asynchronous task responsible for syntax highlighting.
        is_highlighting (bool): Flag indicating whether highlighting is in progress.
    """

    def __init__(self, parser: Parser, language: str):
        """Initialize the lexer with a parser and language.

        Args:
            parser (Parser): The parser associated with the language.
            language (str): The language identifier for syntax highlighting.
        """
        self.parser: Parser = parser
        self.language: str = language
        self.highlight_query, self.injection_query = self.get_query_for_language(
            language
        )
        self.tree: Optional[Tree] = None
        self.last_text: str = ""
        self.cached_styles: List[StyleAndTextTuples] = []
        self.highlighting_task: Optional[asyncio.Task] = None
        self.is_highlighting: bool = False
        super().__init__()

    def _capture_to_style_class(self, capture_name: str) -> str:
        """Convert a Tree-sitter capture name to a style class string.

        Args:
            capture_name (str): The capture name from Tree-sitter.

        Returns:
            str: Style class string for formatting.
        """
        parts = capture_name.split(".")
        styles = [f"class:{part}" for part in parts]
        return " ".join(styles)

    async def _handle_injection(
        self, document: Document, node: Tree, start: int, end: int, depth: int = 0
    ) -> List[Tuple[int, int, str]]:
        """Handle injected languages for syntax highlighting.

        Args:
            document (Document): The document object being lexed.
            node (Tree): The syntax tree node for the injection.
            start (int): Start byte position.
            end (int): End byte position.
            depth (int): The current depth of nested injections.

        Returns:
            List[Tuple[int, int, str]]: List of styled regions for the injection.
        """
        MAX_DEPTH = 5
        if depth > MAX_DEPTH:
            return []

        injection_lang = self._get_injection_language(node)

        if not injection_lang:
            return [(start, end, self._capture_to_style_class("injection.content"))]

        injected_parser = self.get_parser_for_language(injection_lang)
        if not injected_parser:
            return [(start, end, self._capture_to_style_class("injection.content"))]

        injected_tree = injected_parser.parse(bytes(document.text[start:end], "utf8"))
        injected_highlight_query, injected_injection_query = (
            self.get_query_for_language(injection_lang)
        )

        if not injected_highlight_query:
            return [
                (start, end, self._capture_to_style_class(f"{injection_lang}.default"))
            ]

        result = []
        styled_ranges = set()

        injected_captures = injected_highlight_query.captures(injected_tree.root_node)

        for capture_name, nodes in injected_captures.items():
            for node in nodes:
                injected_start = start + node.start_byte
                injected_end = start + node.end_byte
                style_class = self._capture_to_style_class(
                    f"{injection_lang}.{capture_name}"
                )
                if (injected_start, injected_end) not in styled_ranges:
                    result.append((injected_start, injected_end, style_class))
                    styled_ranges.add((injected_start, injected_end))

        all_ranges = sorted(styled_ranges, key=lambda x: x[0])
        last_end = start
        for range_start, range_end in all_ranges:
            if last_end < range_start:
                result.append(
                    (
                        last_end,
                        range_start,
                        self._capture_to_style_class(f"{injection_lang}.default"),
                    )
                )
            last_end = max(last_end, range_end)
        if last_end < end:
            result.append(
                (
                    last_end,
                    end,
                    self._capture_to_style_class(f"{injection_lang}.default"),
                )
            )

        return sorted(result, key=lambda x: x[0])

    async def _parse_document_async(self, document: Document) -> None:
        """Asynchronously parse and highlight a document.

        Args:
            document (Document): The document object being lexed.
        """
        self.is_highlighting = True
        self.tree = self.parser.parse(bytes(document.text, "utf8"))
        self.last_text = document.text
        new_cached_styles: List[StyleAndTextTuples] = []

        char_styles = [""] * len(document.text)

        if self.highlight_query:
            captures = self.highlight_query.captures(self.tree.root_node)
            for capture_name, nodes in captures.items():
                for node in nodes:
                    start, end = node.start_byte, node.end_byte
                    style_class = self._capture_to_style_class(capture_name)
                    for i in range(start, end):
                        if i < len(char_styles):
                            char_styles[i] += (
                                f" {style_class}" if char_styles[i] else style_class
                            )

        if self.injection_query:
            captures = self.injection_query.captures(self.tree.root_node)
            for capture_name, nodes in captures.items():
                for node in nodes:
                    start, end = node.start_byte, node.end_byte
                    if capture_name == "injection.content":
                        injections = await self._handle_injection(
                            document, node, start, end
                        )
                        for inj_start, inj_end, inj_style in injections:
                            for i in range(inj_start, inj_end):
                                if i < len(char_styles):
                                    char_styles[i] += (
                                        f" {inj_style}" if char_styles[i] else inj_style
                                    )
                    else:
                        style_class = self._capture_to_style_class(capture_name)
                        for i in range(start, end):
                            if i < len(char_styles):
                                char_styles[i] += (
                                    f" {style_class}" if char_styles[i] else style_class
                                )

                if end % 1000 == 0:
                    await asyncio.sleep(0)

        current_style = ""
        current_text = ""
        line_styles: StyleAndTextTuples = []

        for i, (char, style) in enumerate(zip(document.text, char_styles)):
            if char == "\n":
                if current_text:
                    line_styles.append(
                        (
                            current_style if current_style else "class:default",
                            current_text,
                        )
                    )
                new_cached_styles.append(line_styles)
                line_styles = []
                current_style = ""
                current_text = ""
            elif style != current_style:
                if current_text:
                    line_styles.append(
                        (
                            current_style if current_style else "class:default",
                            current_text,
                        )
                    )
                current_style = style
                current_text = char
            else:
                current_text += char

            if i % 1000 == 0:
                await asyncio.sleep(0)

        if current_text:
            line_styles.append(
                (current_style if current_style else "class:default", current_text)
            )
        if line_styles:
            new_cached_styles.append(line_styles)

        self.cached_styles = new_cached_styles
        self.is_highlighting = False

        get_app().invalidate()

    def _get_injection_language(self, node: Tree) -> Optional[str]:
        """Determine the language of a code block for injection.

        Args:
            node (Tree): The syntax tree node to inspect.

        Returns:
            Optional[str]: The language identifier for the injection.
        """
        if node.type == "inline":
            return "markdown.inline"
        parent = node.parent
        if parent and self.injection_query:
            captures = self.injection_query.captures(parent)
            for capture_name, capture_nodes in captures.items():
                if capture_name == "injection.language" and capture_nodes:
                    for capture_node in capture_nodes:
                        if capture_node.type == "language":
                            return capture_node.text.decode("utf-8")
        return None

    def get_query_for_language(
        self, language: str
    ) -> Tuple[Optional[Query], Optional[Query]]:
        """Retrieve highlight and injection queries for a language.

        Args:
            language (str): The language identifier.

        Returns:
            Tuple[Optional[Query], Optional[Query]]: Queries for syntax highlighting and injections.
        """
        config: "Config" = container["Config"]
        highlight_query = None
        injection_query = None

        locations = [
            config.queries_dir,
            os.path.join(str(files("sno_py")), "data", "queries"),
        ]

        for location in locations:
            highlight_path = os.path.join(location, language, "highlights.scm")
            injection_path = os.path.join(location, language, "injections.scm")

            if os.path.isfile(highlight_path):
                with open(highlight_path, "r") as f:
                    highlight_content = f.read()

                parser = self.get_parser_for_language(language)
                if parser:
                    try:
                        highlight_query = parser.language.query(highlight_content)
                    except Exception:
                        pass
            if os.path.isfile(injection_path) and language != "markdown.inline":
                with open(injection_path, "r") as f:
                    injection_content = f.read()

                parser = self.get_parser_for_language(language)
                if parser:
                    try:
                        injection_query = parser.language.query(injection_content)
                    except Exception:
                        pass

            if highlight_query or injection_query:
                break

        return highlight_query, injection_query

    def lex_document(self, document: Document) -> Callable[[int], StyleAndTextTuples]:
        """Lex a document to generate styled text lines.

        Args:
            document (Document): The document to lex.

        Returns:
            Callable[[int], StyleAndTextTuples]: Function to retrieve styles for a given line number.
        """
        if self.tree is None or document.text != self.last_text:
            if self.highlighting_task:
                self.highlighting_task.cancel()
            self.highlighting_task = get_app().create_background_task(
                self._parse_document_async(document)
            )

        def get_line(lineno: int) -> StyleAndTextTuples:
            if self.is_highlighting or lineno >= len(self.cached_styles):
                return [("class:default", document.lines[lineno])]

            cached_line = "".join(text for _, text in self.cached_styles[lineno])
            current_line = document.lines[lineno]

            if cached_line == current_line:
                return self.cached_styles[lineno]
            else:
                return [("class:default", current_line)]

        return get_line

    def get_parser_for_language(self, language: str) -> Optional[Parser]:
        """Retrieve the Tree-sitter parser for a specified language.

        Args:
            language (str): The language identifier.

        Returns:
            Optional[Parser]: The parser for the specified language.
        """
        try:
            if language == "markdown.inline":
                module = importlib.import_module("tree_sitter_markdown")
            else:
                module = importlib.import_module(f"tree_sitter_{language}")
            lang_func: Callable[[], Any] = getattr(module, "language")
            if lang_func:
                return Parser(Language(lang_func()))
        except ImportError:
            pass
        return None

    @classmethod
    def from_file(cls, file: str, content: str) -> Lexer:
        """Instantiate a lexer based on file content type.

        Args:
            file (str): The filename for which a lexer is needed.
            content (str): The file's content to help determine the language.

        Returns:
            Lexer: A TreeSitterLexer or SimpleLexer based on language support.
        """
        filetypes: "FileType" = container["FileType"]
        language_id: str = filetypes.guess_filetype(file, content)

        language: Optional[Language] = cls.get_language(language_id)
        if language:
            parser: Parser = Parser(language)
            return cls(parser, language_id)

        return SimpleLexer()

    @staticmethod
    def get_language(language_id: str) -> Optional[Language]:
        """Find and load the tree-sitter language module.

        Args:
            language_id (str): The language identifier.

        Returns:
            Optional[Language]: The tree-sitter language object.
        """
        try:
            module = importlib.import_module(f"tree_sitter_{language_id}")
            lang_func: Callable[[], Any] = getattr(module, "language")
            if lang_func:
                return Language(lang_func())
        except ImportError:
            editor: "Editor" = container["Editor"]
            editor.show_message(
                f"Failed to import language: {language_id} (pip install tree_sitter_{language_id})"
            )
        return None
